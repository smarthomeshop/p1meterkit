name: Build and Publish P1MeterKit firmware

on:
  pull_request:
  workflow_dispatch:
    inputs:
      force_all:
        description: 'Force build all versions'
        type: boolean
        default: false
      clean_gh_pages:
        description: 'Clean gh-pages branch (remove old files)'
        type: boolean
        default: false
  schedule:
    # Rebuild monthly with latest ESPHome
    # ESPHome releases ~15th of the month, we build on the 20th
    - cron: '0 3 20 * *'
  push:
    branches:
      - main
    paths:
      - 'p1meterkit-v1/**'
      - 'p1meterkit-v2/**'
      - '.github/workflows/**'
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  # ============================================
  # Detect which versions changed
  # ============================================
  detect-changes:
    name: Detect changed versions
    runs-on: ubuntu-latest
    outputs:
      v1_changed: ${{ steps.changes.outputs.v1 }}
      v2_changed: ${{ steps.changes.outputs.v2 }}
      v1_version: ${{ steps.versions.outputs.v1_version }}
      v2_version: ${{ steps.versions.outputs.v2_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Check for changes in each version
        id: changes
        shell: bash
        run: |
          # Force all on workflow_dispatch or schedule
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "v1=true" >> $GITHUB_OUTPUT
            echo "v2=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "Scheduled build - rebuilding all"
            echo "v1=true" >> $GITHUB_OUTPUT
            echo "v2=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            echo "Tag detected - building all"
            echo "v1=true" >> $GITHUB_OUTPUT
            echo "v2=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Initial commit detection
          if [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]]; then
            echo "Initial commit - building all"
            echo "v1=true" >> $GITHUB_OUTPUT
            echo "v2=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Detect changes per folder
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA=${{ github.event.pull_request.base.sha }}
            HEAD_SHA=${{ github.event.pull_request.head.sha }}
          else
            BASE_SHA=${{ github.event.before }}
            HEAD_SHA=${{ github.sha }}
          fi
          
          # Check for workflow changes - rebuild all
          if git diff --name-only $BASE_SHA $HEAD_SHA | grep -q "^\.github/workflows/"; then
            echo "Workflow changed - rebuilding all"
            echo "v1=true" >> $GITHUB_OUTPUT
            echo "v2=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          V1=$(git diff --name-only $BASE_SHA $HEAD_SHA | grep -q "^p1meterkit-v1/" && echo "true" || echo "false")
          V2=$(git diff --name-only $BASE_SHA $HEAD_SHA | grep -q "^p1meterkit-v2/" && echo "true" || echo "false")
          
          echo "v1=$V1" >> $GITHUB_OUTPUT
          echo "v2=$V2" >> $GITHUB_OUTPUT

      - name: Get versions
        id: versions
        shell: bash
        run: |
          V1_CURRENT=$(grep "software_version:" "p1meterkit-v1/base.yaml" | head -1 | sed 's/.*: *"\([^"]*\)".*/\1/' || echo "1.0")
          V2_CURRENT=$(grep "software_version:" "p1meterkit-v2/base.yaml" | head -1 | sed 's/.*: *"\([^"]*\)".*/\1/' || echo "2.0")
          
          echo "v1_version=$V1_CURRENT" >> $GITHUB_OUTPUT
          echo "v2_version=$V2_CURRENT" >> $GITHUB_OUTPUT

  # ============================================
  # Build V1
  # ============================================
  build-v1:
    name: Build V1
    needs: [detect-changes]
    if: needs.detect-changes.outputs.v1_changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Inject version into YAML
        run: |
          VERSION="${{ needs.detect-changes.outputs.v1_version }}"
          sed -i "s/^\(\s*software_version:\s*\)\"[^\"]*\"/\1\"${VERSION}\"/" p1meterkit-v1/base.yaml

      - name: Create dummy secrets
        run: |
          printf 'wifi_ssid: "DUMMY"\nwifi_password: "DUMMYPASS"\n' > p1meterkit-v1/secrets.yaml

      - uses: esphome/build-action@v6
        id: esphome-build
        with:
          yaml-file: p1meterkit-v1/p1meterkit.yaml
          version: latest

      - name: Collect outputs
        run: |
          mkdir -p output/p1meterkit-v1
          mv "${{ steps.esphome-build.outputs.name }}"/* output/p1meterkit-v1/

      - uses: actions/upload-artifact@v4
        with:
          name: p1meterkit-v1
          path: output

  # ============================================
  # Build V2
  # ============================================
  build-v2:
    name: Build V2
    needs: [detect-changes]
    if: needs.detect-changes.outputs.v2_changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Inject version into YAML
        run: |
          VERSION="${{ needs.detect-changes.outputs.v2_version }}"
          sed -i "s/^\(\s*software_version:\s*\)\"[^\"]*\"/\1\"${VERSION}\"/" p1meterkit-v2/base.yaml

      - name: Create dummy secrets
        run: |
          printf 'wifi_ssid: "DUMMY"\nwifi_password: "DUMMYPASS"\n' > p1meterkit-v2/secrets.yaml

      - uses: esphome/build-action@v6
        id: esphome-build
        with:
          yaml-file: p1meterkit-v2/p1meterkit.yaml
          version: latest

      - name: Collect outputs
        run: |
          mkdir -p output/p1meterkit-v2
          mv "${{ steps.esphome-build.outputs.name }}"/* output/p1meterkit-v2/

      - uses: actions/upload-artifact@v4
        with:
          name: p1meterkit-v2
          path: output

  # ============================================
  # Publish all to GitHub Pages
  # ============================================
  publish:
    name: Publish to GitHub Pages
    needs: [detect-changes, build-v1, build-v2]
    if: |
      always() &&
      github.event_name != 'pull_request' &&
      github.ref == 'refs/heads/main' &&
      (needs.build-v1.result == 'success' || needs.build-v2.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create output directory
        run: mkdir -p output

      - name: Download V1 artifact
        if: needs.build-v1.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: p1meterkit-v1
          path: output

      - name: Download V2 artifact
        if: needs.build-v2.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: p1meterkit-v2
          path: output

      - name: Create V1 manifest
        if: needs.build-v1.result == 'success'
        run: |
          VERSION="${{ needs.detect-changes.outputs.v1_version }}"
          if [[ -f "output/p1meterkit-v1/manifest.json" ]]; then
            jq --arg version "$VERSION" '{
              "name": "P1MeterKit V1",
              "version": $version,
              "home_assistant_domain": "esphome",
              "new_install_skip_erase": false,
              "builds": [.]
            } | .builds[0].ota.path = "p1meterkit-v1/" + .builds[0].ota.path | .builds[0].parts[].path = "p1meterkit-v1/" + .builds[0].parts[].path' \
              output/p1meterkit-v1/manifest.json > output/p1meterkit-v1-manifest.json
          fi

      - name: Create V2 manifest
        if: needs.build-v2.result == 'success'
        run: |
          VERSION="${{ needs.detect-changes.outputs.v2_version }}"
          if [[ -f "output/p1meterkit-v2/manifest.json" ]]; then
            jq --arg version "$VERSION" '{
              "name": "P1MeterKit V2",
              "version": $version,
              "home_assistant_domain": "esphome",
              "new_install_skip_erase": false,
              "builds": [.]
            } | .builds[0].ota.path = "p1meterkit-v2/" + .builds[0].ota.path | .builds[0].parts[].path = "p1meterkit-v2/" + .builds[0].parts[].path' \
              output/p1meterkit-v2/manifest.json > output/p1meterkit-v2-manifest.json
          fi

      - name: Create README for gh-pages
        run: |
          cat > output/README.md << 'EOF'
          # P1MeterKit firmware – GitHub Pages branch (gh-pages)

          This branch hosts the public firmware artifacts and manifests for P1MeterKit. It is served via GitHub Pages and is intended to be consumed by:
          - ESP Web Tools (browser-based flashing)
          - OTA update integrations (using the JSON manifest)

          ## Do not edit manually
          Files in this branch are generated by the CI workflow in the default branch. Any manual changes will be overwritten on the next publish.

          ## Layout
          - `p1meterkit-v1/` — Firmware binaries for V1 (ESP8266)
          - `p1meterkit-v2/` — Firmware binaries for V2 (ESP32-C3)
          - `p1meterkit-v1-manifest.json` — Aggregate manifest for V1
          - `p1meterkit-v2-manifest.json` — Aggregate manifest for V2

          ## OTA update manifest
          The P1MeterKit V2 firmware consumes the manifest directly for OTA updates.

          ## How this branch is updated
          On pushes to the main branch, the CI pipeline builds all variants and deploys to this branch.
          EOF

      - name: Debug - List output structure
        run: |
          echo "=== Output structure ==="
          find output -type f | head -50

      - name: Deploy to gh-pages
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          branch: gh-pages
          folder: output
          clean: ${{ github.event.inputs.clean_gh_pages == 'true' }}
          force: false
